"""
validator.py â€” gor://a Code Operation Validator

Purpose:
- Validate operations generated by the Coder before execution
- Prevent irreversible or unintended destructive actions
- Guarantee safety, durability, and project integrity
"""

from __future__ import annotations
from typing import List, Dict, Any


class ValidationError(Exception):
    pass


class Validator:

    def __init__(self):
        # Reserved areas that cannot be overwritten by AI
        self.protected_paths = [
            "backend/core_api.py",
            "backend/agent/planner.py",
            "backend/agent/coder.py",
            "backend/agent/generator.py",
            "backend/agent/validator.py",
            "frontend/favicon.png",
            "README.md",
            ".env",
        ]

    def _assert(self, condition: bool, message: str) -> None:
        if not condition:
            raise ValidationError(message)

    def validate(self, operations: List[Dict[str, Any]]) -> None:
        """
        Inspects each operation for structural correctness and safety rules.
        """
        self._assert(isinstance(operations, list), "Operations must be a list.")

        for op in operations:
            self._validate_operation(op)

    def _validate_operation(self, op: Dict[str, Any]) -> None:

        # ----------------------------
        # Structural
        # ----------------------------
        self._assert("action" in op, "Missing 'action' in operation.")
        self._assert("path" in op, "Missing 'path' in operation.")
        self._assert(isinstance(op["path"], str), "'path' must be a string.")

        action = op["action"]
        path = op["path"]

        # ----------------------------
        # Reserved safety
        # ----------------------------
        for protected in self.protected_paths:
            self._assert(
                not path.endswith(protected),
                f"Modification to protected file {path} is not allowed.",
            )

        # ----------------------------
        # Action-Specific Validation
        # ----------------------------

        if action == "create_file":
            self._assert("content" in op, "create_file requires 'content'")
            self._assert(len(op["content"].strip()) > 0, "Cannot create empty file.")
            return

        if action == "overwrite_file":
            self._assert("content" in op, "overwrite_file requires 'content'")
            self._assert(len(op["content"].strip()) > 0, "Cannot overwrite with empty content.")
            return

        if action == "patch_file":
            self._assert("diff" in op, "patch_file requires 'diff'")
            self._assert(
                isinstance(op["diff"], str),
                "'diff' must be a unified diff string.",
            )
            self._assert(len(op["diff"].strip()) > 0, "Cannot apply blank patch.")
            return

        raise ValidationError(f"Unknown action type: {action}")


"""
Example:

validator = Validator()
validator.validate([
    {"action":"create_file","path":"frontend/test.html","content":"<html></html>"}
])
"""
